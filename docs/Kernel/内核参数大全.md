Linux内核参数
http://space.itpub.net/17283404/viewspace-694350

net.ipv4.tcp_syncookies = 1
表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；什么是SYN Cookies:http://www.ibm.com/developerworks/cn/linux/l-syncookie/

net.ipv4.tcp_tw_reuse = 1
表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；

net.ipv4.tcp_tw_recycle = 1
表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。

net.ipv4.tcp_fin_timeout = 30
表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。

net.ipv4.tcp_keepalive_time = 1200
表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时。

net.ipv4.tcp_keepalive_probes = 5
TCP发送keepalive探测以确定该连接已经断开的次数。(注意:保持连接仅在SO_KEEPALIVE套接字选项被打开是才发送.次数默认不需要修改,当然根据情形也可以适当地缩短此值.设置为5比较合适)

net.ipv4.tcp_keepalive_intvl = 15
探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒，也就是没有活动的连接将在大约11分钟以后将被丢弃。(对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)

net.ipv4.ip_local_port_range = 1024 65000
表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。

net.ipv4.tcp_max_syn_backlog = 8192
表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。

net.ipv4.ip_conntrack_max = 655360
在内核内存中netfilter可以同时处理的“任务”（连接跟踪条目）another voice-不要盲目增加ip_conntrack_max: http://blog.csdn.net/dog250/article/details/7107537

net.ipv4.netfilter.ip_conntrack_tcp_timeout_established = 180
跟踪的连接超时结束时间

net.ipv4.tcp_max_tw_buckets = 819200
表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000。设为较小数值此项参数可以控制TIME_WAIT套接字的最大数量，避免服务器被大量的TIME_WAIT套接字拖死。

net.core.somaxconn = 262144
定义了系统中每一个端口最大的监听队列的长度, 对于一个经常处理新连接的高负载 web服务环境来说，默认的 128 太小了。

net.core.netdev_max_backlog = 262144
该参数决定了, 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目, 不要设的过大

net.ipv4.tcp_max_orphans = 262144
系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量，那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制，更应该增加这个值(如果增加了内存之后)。每个孤儿套接字最多能够吃掉你64K不可交换的内存。

net.ipv4.tcp_orphan_retries = 3
本端试图关闭TCP连接之前重试多少次。缺省值是7，相当于50秒~16分钟(取决于RTO)。如果你的机器是一个重载的WEB服务器，你应该考虑减低这个值，因为这样的套接字会消耗很多重要的资源。参见tcp_max_orphans.

net.ipv4.tcp_timestamps = 0
时间戳,0关闭， 1开启，在(请参考RFC 1323)TCP的包头增加12个字节, 关于该配置对TIME_WAIT的影响及可能引起的问题: http://huoding.com/2012/01/19/142 , Timestamps 用在其它一些东西中﹐可以防范那些伪造的 sequence 号码。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 ‘旧封包’。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)

net.ipv4.tcp_synack_retries = 1
tcp_synack_retries 显示或设定 Linux 核心在回应 SYN 要求时会尝试多少次重新发送初始 SYN,ACK 封包后才决定放弃。这是所谓的三段交握 (threeway handshake) 的第二个步骤。即是说系统会尝试多少次去建立由远端启始的 TCP 连线。tcp_synack_retries 的值必须为正整数，并不能超过 255。因为每一次重新发送封包都会耗费约 30 至 40 秒去等待才决定尝试下一次重新发送或决定放弃。tcp_synack_retries 的缺省值为 5，即每一个连线要在约 180 秒 (3 分钟) 后才确定逾时.

net.ipv4.tcp_syn_retries = 1
对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。(对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅仅是针对对外的连接,对进来的连接,是由tcp_retries1 决定的)

net.ipv4.tcp_retries1 = 3
放弃回应一个TCP连接请求前﹐需要进行多少次重试。RFC 规定最低的数值是3﹐这也是默认值﹐根据RTO的值大约在3秒 - 8分钟之间。(注意:这个值同时还决定进入的syn连接)

net.ipv4.tcp_retries2 = 15
在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)

net.ipv4.tcp_sack = 1
使 用 Selective ACK﹐它可以用来查找特定的遗失的数据报— 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。)

net.ipv4.tcp_fack = 1
打开FACK拥塞避免和快速重传功能。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)

net.ipv4.tcp_dsack = 1
允许TCP发送”两个完全相同”的SACK。

net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.all.rp_filter = 1
1 - do source validation by reversed path, as specified in RFC1812 Recommended option for single homed hosts and stub network routers. Could cause troubles for complicated (not loop free) networks running a slow unreliable protocol (sort of RIP), or using static routes.

0 - No source validation.

net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
停用 ipv6 模块

vm.swappiness=5
默认60, Swappiness can be set to values between 0 and 100 inclusive. A low value means the kernel will try to avoid swapping as much as possible where a higher value instead will make the kernel aggressively try to use swap space.

others:

# 避免放大攻击
net.ipv4.icmp_echo_ignore_broadcasts = 1

# 开启恶意icmp错误消息保护
net.ipv4.icmp_ignore_bogus_error_responses = 1

# 开启SYN洪水攻击保护
net.ipv4.tcp_syncookies = 1

# 开启并记录欺骗，源路由和重定向包
net.ipv4.conf.all.log_martians = 1
net.ipv4.conf.default.log_martians = 1

# 处理无源路由的包
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0

# 开启反向路径过滤
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1

# 确保无人能修改路由表
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.secure_redirects = 0

# 不充当路由器
net.ipv4.ip_forward = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

# 开启execshild
kernel.exec-shield = 1
kernel.randomize_va_space = 1

# IPv6设置
net.ipv6.conf.default.router_solicitations = 0
net.ipv6.conf.default.accept_ra_rtr_pref = 0
net.ipv6.conf.default.accept_ra_pinfo = 0
net.ipv6.conf.default.accept_ra_defrtr = 0
net.ipv6.conf.default.autoconf = 0
net.ipv6.conf.default.dad_transmits = 0
net.ipv6.conf.default.max_addresses = 1

# 优化LB使用的端口

# 增加系统文件描述符限制
fs.file-max = 65535

# 允许更多的PIDs (减少滚动翻转问题); may break some programs 32768
kernel.pid_max = 65536

# 增加系统IP端口限制
net.ipv4.ip_local_port_range = 2000 65000

# 增加TCP最大缓冲区大小
net.ipv4.tcp_rmem = 4096 87380 8388608
net.ipv4.tcp_wmem = 4096 87380 8388608

# 增加Linux自动调整TCP缓冲区限制
# 最小，默认和最大可使用的字节数
# 最大值不低于4MB，如果你使用非常高的BDP路径可以设置得更高

# Tcp窗口等
net.core.rmem_max = 8388608
net.core.wmem_max = 8388608
net.core.netdev_max_backlog = 5000
net.ipv4.tcp_window_scaling = 1
文件数限制
在繁忙的服务器上，必须要修改文件数限制，否则很快就会遇见too many open file的错误

使用limit -a 可以查看当前文件数限制， limit -n xxxx 修改的是当期用户当期环境的限制，重启和退出用户就恢复了

与文件数相关的有三处

内核参数fs.file-max

file-max的值是内核所能分配到的最大句柄数。
内核参数fs.file-nr

它有三个值：
  已分配文件句柄的数目
  已使用文件句柄的数目
  文件句柄的最大数目
该参数只读，不修改
配置文件 /etc/security/limits.conf ，加入下面两行

*　　soft　　nofile　　65536
*　　hard　　nofile　　65536
Nginx配置优化
介绍nginx变量和配置很好的文档： http://openresty.org/download/agentzh-nginx-tutorials-zhcn.html

nginx.conf

#运行用户
user www-data;

#nginx进程数，建议和CPU总核心数相同
worker_processes 4;

pid /run/nginx.pid;

#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。
worker_rlimit_nofile 65535;

#工作模式与连接数上限
events {
    #单个进程最大连接数（最大连接数=连接数*进程数）
    worker_connections 65535;

    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型
    use epoll;

    #是否允许Nginx在已经得到一个新连接的通知时，接收尽可能更多的连接。缺省：off
    # multi_accept on;
}

http {

    ##
    # Basic Settings
    ##

    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，
    #如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。
    sendfile on;
    #当使用sendfile函数时，tcp_nopush才起作用，它和指令tcp_nodelay是互斥的。
    tcp_nopush on;
    #设置套接字的TCP_NODELAY = on 选项来完成，这样就禁用了Nagle 算法
    tcp_nodelay on;
    #客户端超时时间，这里不是指整个传输过程的时间， 而是指客户端两个读操作之间的时间，即如果客户端超过这么长时间没有读任何数据，nginx关闭该连接
    send_timeout 60;
    #设置http头中的Keep-Alive
    keepalive_timeout 65;
    #set the maximum size of the types hash tables
    types_hash_max_size 2048;
    #隐藏nginx服务器系统版本等信息
    # server_tokens off;

    #指定一个request可接受的body大小,即请求头里的Content-Length. 如果请求body超过该值，nginx返回413("Request Entity Too Large")
    client_max_body_size 10M;
    #客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k
    client_header_buffer_size 4k;
    #指定允许为客户端请求头最大分配buffer个数和大小.
    large_client_header_buffers 8 128k;

    # server_names_hash_bucket_size 64;
    # server_name_in_redirect off;


    #文件扩展名与文件类型映射表
    include /etc/nginx/mime.types;
    #默认文件类型
    default_type application/octet-stream;

    ##
    # Logging Settings
    ##

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##

    #开启gzip压缩输出
    gzip on;
    #最小压缩文件大小
    gzip_min_length 1k;
    #压缩缓冲区
    gzip_buffers 16 8k;
    #压缩版本
    gzip_http_version 1.1;
    #压缩等级
    gzip_comp_level 6;
    #ie6 不压缩
    gzip_disable "msie6";
    #Enables response header of "Vary: Accept-Encoding".
    gzip_vary on;
    #Nginx作为反向代理时，启用或关闭压缩上游服务器返回内容的选项
    # gzip_proxied any;
    #压缩类型
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

    ##
    # Proxy Global Settings
    ##

    #是否开启buffer， 为on时，尽可能从后端读数据存如buffer， 为off时，收到后端数据立即转发给客户端, 对于long-polling应用，需要关闭proxy_buffering
    proxy_buffering on;
    #存放后端服务器返回结果的buffer大小
    proxy_buffer_size 4k;
    #存放后端服务器返回结果的buffer 个数和大小, buffer满时会写到临时文件
    proxy_buffers 8 4k;
    #可以处于busy状态的buffer总和，它控制了同时传输到客户端的buffer数量
    proxy_busy_buffers_size 16k;
    #定义了跟代理服务器连接的超时时间,必须留意这个time out时间不能超过75秒
    proxy_connect_timeout 60s;
    #headers hash table bucket大小，如果headers名称大于64字符，需要增加此值
    proxy_headers_hash_bucket_size 64;
    #headers hash table大小
    proxy_headers_hash_max_size 512;
    proxy_http_version 1.0;
    #指定nginx等待后端返回数据最长时间，该timeout并不是指整个response时间，而是指两次读之间的时间
    proxy_read_timeout 60s;
    #nginx传送请求到后端最大时间，该timeout并不是指整个传输时间，而是指两次写之间的时间
    proxy_send_timeout 30s;

    ##
    # open file optimize
    ##

    #max指定缓存最大文件数，inactive指定缓存失效时间，如在这段时间文件没被下载，移除缓存
    open_file_cache max=102400 inactive=20s;
    #指定多长时间检查一下open_file_cache中文件的有效性
    open_file_cache_valid    60s;
    #指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数， 如果使用更大的值，文件描述符在cache中总是打开状态
    open_file_cache_min_uses 1;
    #是否cache搜索文件的错误
    open_file_cache_errors   on;


    ##
    # Virtual Host Configs
    ##

    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}







Linux常用的一些内核参数（调优）  2011-05-03 17:18:25
分类： Linux

一.所有的TCP/IP调优参数都位于/proc/sys/net/目录. 例如, 下面是最重要的一些调优参数, 后面是它们的含义: 
1. /proc/sys/net/core/rmem_max — 最大的TCP数据接收缓冲 
2. /proc/sys/net/core/wmem_max — 最大的TCP数据发送缓冲 
3. /proc/sys/net/ipv4/tcp_timestamps — 时间戳在(请参考RFC 1323)TCP的包头增加12个字节 
4. /proc/sys/net/ipv4/tcp_sack — 有选择的应答 
5. /proc/sys/net/ipv4/tcp_window_scaling — 支持更大的TCP窗口. 如果TCP窗口最大超过65535(64K), 必须设置该数值为1 
6. rmem_default — 默认的接收窗口大小 
7. rmem_max — 接收窗口的最大大小 
8. wmem_default — 默认的发送窗口大小 
9. wmem_max — 发送窗口的最大大小 
  /proc目录下的所有内容都是临时性的, 所以重启动系统后任何修改都会丢失. 
  建议在系统启动时自动修改TCP/IP参数: 
  把下面代码增加到/etc/rc.local文件, 然后保存文件, 系统重新引导的时候会自动修改下面的TCP/IP参数: 
echo 256960 > /proc/sys/net/core/rmem_default 
echo 256960 > /proc/sys/net/core/rmem_max 
echo 256960 > /proc/sys/net/core/wmem_default 
echo 256960 > /proc/sys/net/core/wmem_max 
echo 0 > /proc/sys/net/ipv4/tcp_timestamps 
echo 1 > /proc/sys/net/ipv4/tcp_sack 
echo 1 > /proc/sys/net/ipv4/tcp_window_scaling 
  TCP/IP参数都是自解释的, TCP窗口大小设置为256960, 禁止TCP的时间戳(取消在每个数据包的头中增加12字节), 支持更大的TCP窗口和TCP有选择的应答。 
  上面数值的设定是根据互连网连接和最大带宽/延迟率来决定. 
  注: 上面实例中的数值可以实际应用, 但它只包含了一部分参数. 
另外一个方法: 使用 /etc/sysctl.conf 在系统启动时将参数配置成您所设置的值: 
net.core.rmem_default = 256960 
net.core.rmem_max = 256960 
net.core.wmem_default = 256960 
net.core.wmem_max = 256960 
net.ipv4.tcp_timestamps = 0 
net.ipv4.tcp_sack =1 
net.ipv4.tcp_window_scaling = 1 
二.系统内核参数---------------------------------------------------------------- 
1./proc/sys/fs/super-max 
  该文件指定超级块处理程序的最大数目。挂装的任何文件系统需要使用超级块，所以如果挂装了大量文件系统，则可能会用尽超级块处理程序。 
缺省设置：256 
2./proc/sys/fs/super-nr 
  该文件显示当前已分配超级块的数目。该文件是只读的，仅用于显示信息。 
3./proc/sys/kernel 
  /proc/sys/kernel/acct 
该文件有三个可配置值，根据包含日志的文件系统上可用空间的数量（以百分比表示），这些值控制何时开始进行进程记帐： 
如果可用空间低于这个百分比值，则停止进程记帐 
如果可用空间高于这个百分比值，则开始进程记帐 
检查上面两个值的频率（以秒为单位） 
要更改这个文件的某个值，应该回送用空格分隔开的一串数字。 
缺省设置：2 4 30 
  如果包含日志的文件系统上只有少于 2% 的可用空间，则这些值会使记帐停止，如果有 4% 或更多可用空间，则再次启动记帐。每 30 秒做一次检查。 
  4./proc/sys/kernel/ctrl-alt-del 
该文件有一个二进制值，该值控制系统在接收到 ctrl+alt+delete 按键组合时如何反应。这两个值表示： 
零（0）值表示捕获 ctrl+alt+delete，并将其送至 init 程序。这将允许系统可以完美地关闭和重启，就好象您输入 shutdown 命令一样。 
壹（1）值表示不捕获 ctrl+alt+delete，将执行非干净的关闭，就好象直接关闭电源一样。 
缺省设置：0 
5./proc/sys/kernel/domainname 
  该文件允许您配置网络域名。它没有缺省值，也许已经设置了域名，也许没有设置。 
6./proc/sys/kernel/hostname 
  该文件允许您配置网络主机名。它没有缺省值，也许已经设置了主机名，也许没有设置。 
7./proc/ss/kernel/msgmax 
  该文件指定了从一个进程发送到另一个进程的消息的最大长度。进程间的消息传递是在内核的内存中进行，不会交换到磁盘上，所以如果增加该值，则将增加操作系统所使用的内存数量。 
  缺省设置：8192 
8./proc/sys/kernel/msgmnb 
  该文件指定在一个消息队列中最大的字节数。 
  缺省设置：16384 
9./proc/sys/kernel/msgmni 
  该文件指定消息队列标识的最大数目。 
  缺省设置：16 
10./proc/sys/kernel/panic 
  该文件表示如果发生“内核严重错误（kernel panic）”，则内核在重新引导之前等待的时间（以秒为单位）。零（0）秒设置在发生内核严重错误时将禁止重新引导。 
  缺省设置：0 
11./proc/sys/kernel/printk 
  该文件有四个数字值，它们根据日志记录消息的重要性，定义将其发送到何处。关于不同日志级别的更多信息，请阅读 syslog(2) 联机帮助页。该文件的四个值为： 
  控制台日志级别：优先级高于该值的消息将被打印至控制台 
  缺省的消息日志级别：将用该优先级来打印没有优先级的消息 
  最低的控制台日志级别：控制台日志级别可被设置的最小值（最高优先级） 
  缺省的控制台日志级别：控制台日志级别的缺省值 
  缺省设置：6 4 1 7 
12./proc/sys/kernel/shmall 
  该文件是在任何给定时刻系统上可以使用的共享内存的总量（以字节为单位）。 
  缺省设置：2097152 
13./proc/sys/kernel/shmax 
  该文件指定内核所允许的最大共享内存段的大小（以字节为单位）。 
  缺省设置：33554432 
14./proc/sys/kernel/shmmni 
  该文件表示用于整个系统共享内存段的最大数目。 
  缺省设置：4096 
15./proc/sys/kernel/sysrq 
  如果该文件指定的值为非零，则激活 System Request Key。 
  缺省设置：0 
16./proc/sys/kernel/threads-max 
  该文件指定内核所能使用的线程的最大数目。 
  缺省设置：2048 
17./proc/sys/net 
  /proc/sys/net/core/message_burst 
  写新的警告消息所需的时间（以 1/10 秒为单位）；在这个时间内所接收到的其它警告消息会被丢弃。这用于防止某些企图用消息“淹没”您系统的人所使用的拒绝服务（Denial of Service）攻击。 
  缺省设置：50（5 秒） 
18./proc/sys/net/core/message_cost 
  该文件存有与每个警告消息相关的成本值。该值越大，越有可能忽略警告消息。 
  缺省设置：5 
19./proc/sys/net/core/netdev_max_backlog 
  该文件指定了，在接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。 
  缺省设置：300 
20./proc/sys/net/core/optmem_max 
  该文件指定了每个套接字所允许的最大缓冲区的大小。 
21./proc/sys/net/core/rmem_default 
  该文件指定了接收套接字缓冲区大小的缺省值（以字节为单位）。 
22./proc/sys/net/core/rmem_max 
  该文件指定了接收套接字缓冲区大小的最大值（以字节为单位）。 
23./proc/sys/net/core/wmem_default 
  该文件指定了发送套接字缓冲区大小的缺省值（以字节为单位）。 
24./proc/sys/net/core/wmem_max 
  该文件指定了发送套接字缓冲区大小的最大值（以字节为单位）。 
25./proc/sys/net/ipv4 
  所有 IPv4 和 IPv6 的参数都被记录在内核源代码文档中。请参阅文件 /usr/src/linux/Documentation/networking/ip-sysctl.txt。 
26./proc/sys/net/ipv6 
  同 IPv4。 
27./proc/sys/vm 
   /proc/sys/vm/buffermem 
  该文件控制用于缓冲区内存的整个系统内存的数量（以百分比表示）。它有三个值，通过把用空格相隔的一串数字写入该文件来设置这三个值。 
  用于缓冲区的内存的最低百分比 
  如果发生所剩系统内存不多，而且系统内存正在减少这种情况，系统将试图维护缓冲区内存的数量。 
  用于缓冲区的内存的最高百分比 
  缺省设置：2 10 60 
28./proc/sys/vm/freepages 
  该文件控制系统如何应对各种级别的可用内存。它有三个值，通过把用空格相隔的一串数字写入该文件来设置这三个值。 
  如果系统中可用页面的数目达到了最低限制，则只允许内核分配一些内存。 
  如果系统中可用页面的数目低于这一限制，则内核将以较积极的方式启动交换，以释放内存，从而维持系统性能。 
  内核将试图保持这个数量的系统内存可用。低于这个值将启动内核交换。 
  缺省设置：512 768 1024 
29./proc/sys/vm/kswapd 
  该文件控制允许内核如何交换内存。它有三个值，通过把用空格相隔的一串数字写入该文件来设置这三个值： 
  内核试图一次释放的最大页面数目。如果想增加内存交换过程中的带宽，则需要增加该值。 
  内核在每次交换中试图释放页面的最少次数。 
  内核在一次交换中所写页面的数目。这对系统性能影响最大。这个值越大，交换的数据越多，花在磁盘寻道上的时间越少。然而，这个值太大会因“淹没”请求队列而反过来影响系统性能。 
  缺省设置：512 32 8 
30./proc/sys/vm/pagecache 
  该文件与 /proc/sys/vm/buffermem 的工作内容一样，但它是针对文件的内存映射和一般高速缓存。 
  使内核设置具有持久性 
  这里提供了一个方便的实用程序，用于更改 /proc/sys 目录下的任何内核参数。它使您可以更改运行中的内核（类似于上面用到的 echo 和重定向方法），但它还有一个在系统引导时执行的配置文件。这使您可以更改运行中的内核，并将这些更改添加到配置文件，以便于在系统重新引导之后，这些更改仍然生效。 
  该实用程序称为 sysctl，在 sysctl(8) 的联机帮助页中，对这个实用程序进行了完整的文档说明。sysctl 的配置文件是 /etc/sysctl.conf，可以编辑该文件，并在 sysctl.conf(8) 下记录了该文件。sysctl 将 /proc/sys 下的文件视为可以更改的单个变量。所以，以 /proc/sys 下的文件 /proc/sys/fs/file-max 为例，它表示系统中所允许的文件句柄的最大数目，这个文件被表示成 fs.file-max。 
  这个示例揭示了 sysctl 表示法中的一些奇妙事情。由于 sysctl 只能更改 /proc/sys 目录下的变量，并且人们始终认为变量是在这个目录下，因此省略了变量名的那一部分（/proc/sys）。另一个要说明的更改是，将目录分隔符（正斜杠 /）换成了英文中的句号（点 .）。 
  将 /proc/sys 中的文件转换成 sysctl 中的变量有两个简单的规则： 
  去掉前面部分 /proc/sys。 
  将文件名中的正斜杠变为点。 
  这两条规则使您能将 /proc/sys 中的任一文件名转换成 sysctl 中的任一变量名。一般文件到变量的转换为： 
  /proc/sys/dir/file --> dir.file 
  dir1.dir2.file --> /proc/sys/dir1/dir2/file 
  可以使用命令 sysctl -a 查看所有可以更改的变量和其当前设置。 
  用 sysctl 还可以更改变量，它所做的工作与上面所用的 echo 方法完全一样。其表示法为： 
  sysctl -w dir.file="value" 
  还是用 file-max 作为示例，使用下面两种方法中的一种将该值更改为 16384。